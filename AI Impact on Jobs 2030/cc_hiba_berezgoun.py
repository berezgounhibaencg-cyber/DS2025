# -*- coding: utf-8 -*-
"""CC HIBA BEREZGOUN.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ApF301TR7q9lq_F_WwM6RKd9qZEEHMoS
"""

# Installation des d√©pendances (d√©commenter si n√©cessaire)
# !pip install kagglehub[pandas-datasets]
# !pip install pandas

import kagglehub
from kagglehub import KaggleDatasetAdapter
import pandas as pd
from typing import Optional

def load_ai_impact_data(file_path: str = "ai_impact_on_jobs_2030.csv", **pandas_kwargs) -> Optional[pd.DataFrame]:
    """
    Charge un fichier CSV sp√©cifique du dataset 'khushikyad001/ai-impact-on-jobs-2030'
    depuis Kaggle directement dans un DataFrame Pandas.

    Args:
        file_path (str): Le nom du fichier CSV √† charger dans le dataset.
                         (Par d√©faut, 'ai_impact_on_jobs_2030.csv', le fichier principal.)
        **pandas_kwargs: Arguments suppl√©mentaires pass√©s directement √† la fonction
                         de lecture Pandas (ex: sep, header, index_col, etc.).

    Returns:
        Optional[pd.DataFrame]: Le DataFrame Pandas charg√©, ou None en cas d'erreur.
    """
    # Constantes pour la clart√© et la maintenabilit√©
    KAGGLE_REF = "khushikyad001/ai-impact-on-jobs-2030"

    if not file_path:
        print("‚ùå Erreur : Le chemin du fichier (file_path) ne peut pas √™tre vide.")
        return None

    print(f"ü§ñ Tentative de chargement du fichier '{file_path}' du dataset Kaggle : {KAGGLE_REF}...")

    try:
        # Appel √† l'API de chargement en utilisant l'adaptateur PANDAS
        df = kagglehub.load_dataset(
            model_reference=KaggleDatasetAdapter.PANDAS,
            ref=KAGGLE_REF,
            path=file_path,
            pandas_kwargs=pandas_kwargs
        )

        print("\n‚úÖ Chargement r√©ussi.")
        print("---")
        return df

    except Exception as e:
        print(f"\n‚ùå Erreur lors du chargement du dataset : {e}")
        print("V√©rifiez la connexion, l'installation de 'kagglehub[pandas-datasets]' et la r√©f√©rence.")
        return None

# --- Ex√©cution du code ---

# 3. Appel de la fonction pour ex√©cuter le chargement

# Le nom de fichier principal est d√©fini par d√©faut dans la fonction,
# mais il est explicit√© ici pour la clart√©.
NOM_FICHIER = "ai_impact_on_jobs_2030.csv"

df_ai_jobs = load_ai_impact_data(file_path=NOM_FICHIER)

# 4. Affichage du r√©sultat si le chargement a r√©ussi
if df_ai_jobs is not None:
    print("Type de l'objet charg√© :", type(df_ai_jobs))
    print("Shape du DataFrame :", df_ai_jobs.shape)
    print("\nPremi√®res 5 lignes :")
    print(df_ai_jobs.head())

# --- √âTAPE 1 : INSTALLATION & IMPORTS N√âCESSAIRES ---
# Assurez-vous d'avoir install√© ces librairies dans votre environnement Colab:
# !pip install scikit-learn matplotlib pandas numpy seaborn

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler

# --- √âTAPE 2 : SIMULATION DES DONN√âES (REMplace le chargement de Kaggle) ---

# Simulation d'un DataFrame 'df' typique d'un dataset sur l'impact de l'IA
np.random.seed(42)
n_jobs = 100

# Pourcentage de t√¢ches automatisables (0 √† 100%)
df = pd.DataFrame()
df['Taches_Automatisees_Pct'] = np.random.rand(n_jobs) * 80 + 10

# Salaire Annuel Moyen (en K‚Ç¨)
# Hypoth√®se : Moins de t√¢ches automatis√©es = Salaire potentiellement plus √©lev√© (pour l'exemple)
df['Salaire_Moyen_kE'] = 80 - 0.5 * df['Taches_Automatisees_Pct'] + np.random.randn(n_jobs) * 15

# Cat√©gorie de risque d'obsolescence (Binaire : 0=Faible/Moyen Risque, 1=Haut Risque)
# Hypoth√®se : T√¢ches automatis√©es > 50% => Haut Risque
df['Haut_Risque_Obsolescence'] = (df['Taches_Automatisees_Pct'] > 50).astype(int)

print("‚úÖ DataFrame 'df' simul√© pour l'analyse.")

# --- √âTAPE 3 : ANALYSE ET TRAC√â DES GRAPHES ---

fig, axes = plt.subplots(1, 2, figsize=(16, 6))
fig.suptitle('Analyse de l\'Impact de l\'IA sur l\'Emploi (Simul√©)', fontsize=18)

# =================================================================
# GRAPHE 1 : R√©gression Lin√©aire (Salaire vs. Automatisation)
# =================================================================

# Pr√©paration du mod√®le Lin√©aire
X_lin = df[['Taches_Automatisees_Pct']].values
y_lin = df['Salaire_Moyen_kE'].values
model_linear = LinearRegression()
model_linear.fit(X_lin, y_lin)
y_lin_pred = model_linear.predict(X_lin)

# Trac√© (Axe Gauche)
axes[0].scatter(X_lin, y_lin, color='#007acc', alpha=0.6, label='Donn√©es par m√©tier')
axes[0].plot(X_lin, y_lin_pred, color='red', linewidth=3, label='Tendance Lin√©aire')
axes[0].set_title('1. Tendance : Salaire en fonction des T√¢ches Automatisables')
axes[0].set_xlabel('Pourcentage de T√¢ches Automatisables (%)')
axes[0].set_ylabel('Salaire Annuel Moyen (k‚Ç¨)')
axes[0].legend()
axes[0].grid(True, linestyle='--', alpha=0.5)


# =================================================================
# GRAPHE 2 : Distribution (Risque d'Obsolescence par Cat√©gorie)
# =================================================================

# Trac√© (Axe Droit) - Utilisation d'un d√©compte (Count Plot) pour visualiser la proportion
sns.countplot(
    x='Haut_Risque_Obsolescence',
    data=df,
    ax=axes[1],
    palette=['#4CAF50', '#FF5733'] # Vert pour faible risque, Rouge pour haut risque
)
axes[1].set_title('2. Distribution des M√©tiers par Niveau de Risque d\'Obsolescence')
axes[1].set_xlabel('Niveau de Risque (0: Faible/Moyen, 1: Haut Risque)')
axes[1].set_ylabel('Nombre de M√©tiers')
axes[1].set_xticks([0, 1])
axes[1].set_xticklabels(['Faible/Moyen Risque', 'Haut Risque'])
axes[1].grid(axis='y', linestyle='--', alpha=0.5)

plt.tight_layout(rect=[0, 0.03, 1, 0.95])
plt.show()